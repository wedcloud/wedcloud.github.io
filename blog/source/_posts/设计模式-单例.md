---
title: 设计模式-单例
tags: [设计模式]
categories:
  - 设计模式
  - 单例
date: 2020-05-25 16:47:02
---

# 单例

## 静态常量(饿汉式)

```java
public class SingletonStatic {

  private static final SingletonStatic singletonStatic = new SingletonStatic();

  private SingletonStatic() {}

  public static SingletonStatic getInstance() {
    return singletonStatic;
  }
}
```

> 类装载就会初始化对象，可能会造成是浪费内存（线程安全）

## 双重校验（懒汉式）

```java
public class SingletonDoubleCheck {
  /**
   * 使用 volatile 保证可见性、禁止指令重排
   *
   * <p>singletonDoubleCheck = new SingletonDoubleCheck() 这一步操作不是原子性操作，它分为三步，1 分配空间 2 初始化对象 3 对象指向空间
   *
   * <p>如果不是用 volatile ，这三步顺序可能会出现重排序，就存在对象还没有初始化，就被返回了，导致对象不是单例
   */
  private static volatile SingletonDoubleCheck singletonDoubleCheck;

  private SingletonDoubleCheck() {}

  public static SingletonDoubleCheck getInstance() {
    if (singletonDoubleCheck == null) {
      synchronized (SingletonDoubleCheck.class) {
        if (singletonDoubleCheck == null) {
          singletonDoubleCheck = new SingletonDoubleCheck();
        }
      }
    }
    return singletonDoubleCheck;
  }
}
```

## 静态内部类

```java
public class SingletonStaticClass {

  private SingletonStaticClass() {}

  static class SingletonClass {
    private static final SingletonStaticClass singletonStaticClass = new SingletonStaticClass();
  }

  public static SingletonStaticClass getInstance() {
    return SingletonClass.singletonStaticClass;
  }
}
```

>1. 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存
>2. 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

## 枚举(推荐)

```java
public enum SingletonEnum {
  /** 单例 */
  INSTANCE;

  public void fun() {
    System.out.println("q");
  }
}
```

>避免出现线程不安全问题，还能防止通过反序列化（反射）重新创建对象

## 使用场景

* 频繁创建和销毁的对象
* 创建对象时消耗资源过多，但又经常使用的对象（例如：数据源、session工厂等）